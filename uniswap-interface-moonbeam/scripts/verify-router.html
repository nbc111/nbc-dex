<!DOCTYPE html>
<html>
<head>
    <title>éªŒè¯ Router åˆçº¦</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .section {
            background: #2a2a2a;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border: 1px solid #00ff00;
        }
        .success { color: #00ff00; }
        .error { color: #ff0000; }
        .warning { color: #ffaa00; }
        .info { color: #00aaff; }
        button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-weight: bold;
            border-radius: 3px;
        }
        button:hover {
            background: #00cc00;
        }
        pre {
            background: #000;
            padding: 10px;
            border-radius: 3px;
            overflow-x: auto;
        }
        .result {
            margin-top: 10px;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>ğŸ” NBC Router åˆçº¦éªŒè¯å·¥å…·</h1>
    
    <div class="section">
        <h2>åˆçº¦åœ°å€</h2>
        <pre>
Router:  0x3d53f590c82a61f85e6B1f0813e509AEAA0b4991
Factory: 0xf0616CCDa274b6DbFa645d70f8Dc0f617707E793
WNBC:    0xFA3956c0620488E2ccdfc48BB02baeB8BDa286fC
        </pre>
    </div>

    <div class="section">
        <h2>éªŒè¯æ­¥éª¤</h2>
        <button onclick="checkConnection()">1. æ£€æŸ¥è¿æ¥</button>
        <button onclick="verifyRouterExists()">2. éªŒè¯ Router å­˜åœ¨</button>
        <button onclick="verifyRouterConfig()">3. éªŒè¯ Router é…ç½®</button>
        <button onclick="testAddLiquidity()">4. æµ‹è¯•æ·»åŠ æµåŠ¨æ€§</button>
        <button onclick="runAllTests()">ğŸš€ è¿è¡Œå…¨éƒ¨æµ‹è¯•</button>
        <div id="output" class="result"></div>
    </div>

    <script>
        const ROUTER_ADDRESS = '0x3d53f590c82a61f85e6B1f0813e509AEAA0b4991';
        const FACTORY_ADDRESS = '0xf0616CCDa274b6DbFa645d70f8Dc0f617707E793';
        const WNBC_ADDRESS = '0xFA3956c0620488E2ccdfc48BB02baeB8BDa286fC';
        const BTC_ADDRESS = '0x5EaA2c6ae3bFf47D2188B64F743Ec777733a80ac';
        const ETH_ADDRESS = '0x934EbeB6D7D3821B604A5D10F80619d5bcBe49C3';
        
        let output = document.getElementById('output');
        
        function log(message, type = 'info') {
            const colors = {
                success: '#00ff00',
                error: '#ff0000',
                warning: '#ffaa00',
                info: '#00aaff'
            };
            const timestamp = new Date().toLocaleTimeString();
            output.innerHTML += `<span style="color: ${colors[type]}">[${timestamp}] ${message}</span>\n`;
            output.scrollTop = output.scrollHeight;
        }
        
        async function checkConnection() {
            log('=== æ£€æŸ¥ MetaMask è¿æ¥ ===', 'info');
            
            if (!window.ethereum) {
                log('âŒ æœªæ£€æµ‹åˆ° MetaMask', 'error');
                return false;
            }
            
            try {
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                if (accounts.length === 0) {
                    log('âŒ æœªè¿æ¥è´¦æˆ·', 'error');
                    return false;
                }
                
                log(`âœ… å·²è¿æ¥è´¦æˆ·: ${accounts[0]}`, 'success');
                
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                const chainIdDec = parseInt(chainId, 16);
                log(`âœ… Chain ID: ${chainIdDec} (${chainId})`, 'success');
                
                if (chainIdDec !== 1281) {
                    log('âš ï¸  è­¦å‘Š: å½“å‰ä¸åœ¨ NBC é“¾ (1281)', 'warning');
                }
                
                const balance = await window.ethereum.request({
                    method: 'eth_getBalance',
                    params: [accounts[0], 'latest']
                });
                log(`âœ… NBC ä½™é¢: ${parseInt(balance, 16) / 1e18} NBC\n`, 'success');
                
                return true;
            } catch (err) {
                log(`âŒ é”™è¯¯: ${err.message}`, 'error');
                return false;
            }
        }
        
        async function verifyRouterExists() {
            log('=== éªŒè¯ Router åˆçº¦å­˜åœ¨ ===', 'info');
            
            try {
                const code = await window.ethereum.request({
                    method: 'eth_getCode',
                    params: [ROUTER_ADDRESS, 'latest']
                });
                
                if (code === '0x' || code === '0x0') {
                    log(`âŒ Router åˆçº¦ä¸å­˜åœ¨: ${ROUTER_ADDRESS}`, 'error');
                    return false;
                }
                
                log(`âœ… Router åˆçº¦å­˜åœ¨`, 'success');
                log(`   ä»£ç é•¿åº¦: ${code.length} å­—èŠ‚\n`, 'info');
                return true;
            } catch (err) {
                log(`âŒ é”™è¯¯: ${err.message}`, 'error');
                return false;
            }
        }
        
        async function verifyRouterConfig() {
            log('=== éªŒè¯ Router é…ç½® ===', 'info');
            
            try {
                // æ£€æŸ¥ factory()
                log('æ£€æŸ¥ factory()...', 'info');
                const factoryData = '0xc45a0155'; // factory()
                const factoryResult = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{
                        to: ROUTER_ADDRESS,
                        data: factoryData
                    }, 'latest']
                });
                
                const factoryAddr = '0x' + factoryResult.slice(-40);
                log(`   Factory åœ°å€: ${factoryAddr}`, 'info');
                
                if (factoryAddr.toLowerCase() === FACTORY_ADDRESS.toLowerCase()) {
                    log(`   âœ… Factory åœ°å€æ­£ç¡®`, 'success');
                } else {
                    log(`   âŒ Factory åœ°å€ä¸åŒ¹é…!`, 'error');
                    log(`      æœŸæœ›: ${FACTORY_ADDRESS}`, 'error');
                    log(`      å®é™…: ${factoryAddr}`, 'error');
                    return false;
                }
                
                // æ£€æŸ¥ WETH()
                log('æ£€æŸ¥ WETH()...', 'info');
                const wethData = '0xad5c4648'; // WETH()
                const wethResult = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{
                        to: ROUTER_ADDRESS,
                        data: wethData
                    }, 'latest']
                });
                
                const wethAddr = '0x' + wethResult.slice(-40);
                log(`   WETH åœ°å€: ${wethAddr}`, 'info');
                
                if (wethAddr.toLowerCase() === WNBC_ADDRESS.toLowerCase()) {
                    log(`   âœ… WETH åœ°å€æ­£ç¡®\n`, 'success');
                } else {
                    log(`   âŒ WETH åœ°å€ä¸åŒ¹é…!`, 'error');
                    log(`      æœŸæœ›: ${WNBC_ADDRESS}`, 'error');
                    log(`      å®é™…: ${wethAddr}\n`, 'error');
                    return false;
                }
                
                return true;
            } catch (err) {
                log(`âŒ é”™è¯¯: ${err.message}`, 'error');
                return false;
            }
        }
        
        async function testAddLiquidity() {
            log('=== æµ‹è¯•æ·»åŠ æµåŠ¨æ€§ ===', 'info');
            
            try {
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                const account = accounts[0];
                
                // æ£€æŸ¥ä»£å¸ä½™é¢
                log('æ£€æŸ¥ä»£å¸ä½™é¢...', 'info');
                const balanceOfData = '0x70a08231' + account.slice(2).padStart(64, '0');
                
                const btcBalance = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{ to: BTC_ADDRESS, data: balanceOfData }, 'latest']
                });
                const btcBal = parseInt(btcBalance, 16) / 1e18;
                log(`   BTC ä½™é¢: ${btcBal}`, btcBal > 0 ? 'success' : 'error');
                
                const ethBalance = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{ to: ETH_ADDRESS, data: balanceOfData }, 'latest']
                });
                const ethBal = parseInt(ethBalance, 16) / 1e18;
                log(`   ETH ä½™é¢: ${ethBal}`, ethBal > 0 ? 'success' : 'error');
                
                if (btcBal === 0 || ethBal === 0) {
                    log('âŒ ä»£å¸ä½™é¢ä¸è¶³ï¼Œæ— æ³•æµ‹è¯•\n', 'error');
                    return false;
                }
                
                // æ£€æŸ¥æˆæƒ
                log('æ£€æŸ¥æˆæƒ...', 'info');
                const allowanceData = '0xdd62ed3e' + 
                    account.slice(2).padStart(64, '0') + 
                    ROUTER_ADDRESS.slice(2).padStart(64, '0');
                
                const btcAllowance = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{ to: BTC_ADDRESS, data: allowanceData }, 'latest']
                });
                const btcAllow = parseInt(btcAllowance, 16);
                log(`   BTC æˆæƒ: ${btcAllow > 0 ? 'âœ… å·²æˆæƒ' : 'âŒ æœªæˆæƒ'}`, btcAllow > 0 ? 'success' : 'error');
                
                const ethAllowance = await window.ethereum.request({
                    method: 'eth_call',
                    params: [{ to: ETH_ADDRESS, data: allowanceData }, 'latest']
                });
                const ethAllow = parseInt(ethAllowance, 16);
                log(`   ETH æˆæƒ: ${ethAllow > 0 ? 'âœ… å·²æˆæƒ' : 'âŒ æœªæˆæƒ'}`, ethAllow > 0 ? 'success' : 'error');
                
                // å°è¯•ä¼°ç®— gas
                log('\nå°è¯•ä¼°ç®—æ·»åŠ æµåŠ¨æ€§çš„ gas...', 'info');
                
                const amountA = '0x' + (1n * 10n**18n).toString(16); // 1 BTC
                const amountB = '0x' + (1n * 10n**18n).toString(16); // 1 ETH
                const minA = '0x' + (95n * 10n**16n).toString(16); // 0.95 BTC
                const minB = '0x' + (95n * 10n**16n).toString(16); // 0.95 ETH
                const deadline = '0x' + (Math.floor(Date.now() / 1000) + 1200).toString(16);
                
                const addLiquidityData = '0xe8e33700' + // addLiquidity
                    BTC_ADDRESS.slice(2).padStart(64, '0') +
                    ETH_ADDRESS.slice(2).padStart(64, '0') +
                    amountA.slice(2).padStart(64, '0') +
                    amountB.slice(2).padStart(64, '0') +
                    minA.slice(2).padStart(64, '0') +
                    minB.slice(2).padStart(64, '0') +
                    account.slice(2).padStart(64, '0') +
                    deadline.slice(2).padStart(64, '0');
                
                try {
                    const gasEstimate = await window.ethereum.request({
                        method: 'eth_estimateGas',
                        params: [{
                            from: account,
                            to: ROUTER_ADDRESS,
                            data: addLiquidityData
                        }]
                    });
                    
                    log(`âœ… Gas ä¼°ç®—æˆåŠŸ: ${parseInt(gasEstimate, 16)}`, 'success');
                    log('âœ… Router åˆçº¦åŠŸèƒ½æ­£å¸¸!\n', 'success');
                    return true;
                } catch (gasErr) {
                    log(`âŒ Gas ä¼°ç®—å¤±è´¥: ${gasErr.message}`, 'error');
                    
                    // å°è¯•è§£æé”™è¯¯
                    if (gasErr.message.includes('INSUFFICIENT')) {
                        log('   å¯èƒ½åŸå› : ä»£å¸ä½™é¢æˆ–æˆæƒä¸è¶³', 'warning');
                    } else if (gasErr.message.includes('EXPIRED')) {
                        log('   å¯èƒ½åŸå› : Deadline è¿‡æœŸ', 'warning');
                    } else {
                        log('   å¯èƒ½åŸå› : Router åˆçº¦å®ç°æœ‰é—®é¢˜', 'warning');
                    }
                    
                    log('\n', 'info');
                    return false;
                }
            } catch (err) {
                log(`âŒ é”™è¯¯: ${err.message}\n`, 'error');
                return false;
            }
        }
        
        async function runAllTests() {
            output.innerHTML = '';
            log('ğŸš€ å¼€å§‹è¿è¡Œæ‰€æœ‰æµ‹è¯•...\n', 'info');
            
            const step1 = await checkConnection();
            if (!step1) {
                log('\nâŒ æµ‹è¯•ä¸­æ­¢: è¿æ¥æ£€æŸ¥å¤±è´¥', 'error');
                return;
            }
            
            const step2 = await verifyRouterExists();
            if (!step2) {
                log('\nâŒ æµ‹è¯•ä¸­æ­¢: Router ä¸å­˜åœ¨', 'error');
                return;
            }
            
            const step3 = await verifyRouterConfig();
            if (!step3) {
                log('\nâŒ æµ‹è¯•ä¸­æ­¢: Router é…ç½®é”™è¯¯', 'error');
                return;
            }
            
            const step4 = await testAddLiquidity();
            
            if (step4) {
                log('='.repeat(50), 'success');
                log('ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡! Router åˆçº¦æ­£å¸¸å·¥ä½œ!', 'success');
                log('='.repeat(50), 'success');
            } else {
                log('='.repeat(50), 'error');
                log('âš ï¸  éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥ä¸Šè¿°é”™è¯¯ä¿¡æ¯', 'warning');
                log('='.repeat(50), 'error');
            }
        }
    </script>
</body>
</html>
