<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swap è¯Šæ–­å·¥å…·</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        h1 {
            color: #007bff;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        h2 {
            color: #333;
            margin-top: 30px;
            border-left: 4px solid #007bff;
            padding-left: 10px;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #dee2e6;
        }
        .success {
            color: #28a745;
            font-weight: bold;
        }
        .error {
            color: #dc3545;
            font-weight: bold;
        }
        .warning {
            color: #ffc107;
            font-weight: bold;
        }
        .info {
            color: #17a2b8;
            font-weight: bold;
        }
        .section {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” Swap è¯Šæ–­å·¥å…·</h1>
        <p>æ­¤å·¥å…·ç”¨äºè¯Šæ–­ä¸ºä»€ä¹ˆ Swap é¡µé¢æ— æ³•è®¡ç®—è¾“å‡ºæ•°é‡ã€‚</p>
        
        <div class="section">
            <h2>1. æ£€æŸ¥é…ç½®</h2>
            <button onclick="checkConfig()">æ£€æŸ¥é…ç½®</button>
            <pre id="configResult"></pre>
        </div>

        <div class="section">
            <h2>2. æ£€æŸ¥äº¤æ˜“å¯¹åœ°å€è®¡ç®—</h2>
            <button onclick="checkPairAddress()">è®¡ç®— WDEV/ETH äº¤æ˜“å¯¹åœ°å€</button>
            <pre id="pairAddressResult"></pre>
        </div>

        <div class="section">
            <h2>3. æ£€æŸ¥äº¤æ˜“å¯¹æ˜¯å¦å­˜åœ¨</h2>
            <button onclick="checkPairExists()">æ£€æŸ¥äº¤æ˜“å¯¹æ˜¯å¦å­˜åœ¨</button>
            <pre id="pairExistsResult"></pre>
        </div>

        <div class="section">
            <h2>4. æ£€æŸ¥ Reserves</h2>
            <button onclick="checkReserves()">è·å– Reserves</button>
            <pre id="reservesResult"></pre>
        </div>

        <div class="section">
            <h2>5. æ£€æŸ¥ Multicall</h2>
            <button onclick="checkMulticall()">æµ‹è¯• Multicall</button>
            <pre id="multicallResult"></pre>
        </div>

        <div class="section">
            <h2>6. å®Œæ•´è¯Šæ–­</h2>
            <button onclick="fullDiagnosis()">è¿è¡Œå®Œæ•´è¯Šæ–­</button>
            <pre id="fullDiagnosisResult"></pre>
        </div>
    </div>

    <script>
        // é…ç½®å¸¸é‡
        const CONFIG = {
            chainId: 1281,
            factory: '0xf0616CCDa274b6DbFa645d70f8Dc0f617707E793',
            wdev: '0xFA3956c0620488E2ccdfc48BB02baeB8BDa286fC',
            eth: '0x934EbeB6D7D3821B604A5D10F80619d5bcBe49C3',
            multicall: '0xF396bb272c5f11EF5E172bAEEC49e9cC895c589a',
            initCodeHash: '0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'
        };

        // æ£€æŸ¥æ˜¯å¦è¿æ¥äº†é’±åŒ…
        function checkWallet() {
            if (typeof window.ethereum === 'undefined') {
                throw new Error('è¯·å…ˆè¿æ¥ MetaMask é’±åŒ…');
            }
            return window.ethereum;
        }

        // è·å– provider
        async function getProvider() {
            const ethereum = checkWallet();
            await ethereum.request({ method: 'eth_requestAccounts' });
            return ethereum;
        }

        // æ£€æŸ¥é…ç½®
        async function checkConfig() {
            const result = document.getElementById('configResult');
            result.textContent = 'æ£€æŸ¥ä¸­...\n';
            
            try {
                const ethereum = await getProvider();
                const chainId = await ethereum.request({ method: 'eth_chainId' });
                const chainIdInt = parseInt(chainId, 16);
                
                let output = '=== é…ç½®æ£€æŸ¥ ===\n\n';
                output += `å½“å‰ Chain ID: ${chainIdInt} (æœŸæœ›: ${CONFIG.chainId})\n`;
                output += chainIdInt === CONFIG.chainId ? 'âœ… Chain ID æ­£ç¡®\n' : 'âŒ Chain ID ä¸åŒ¹é…\n';
                output += `\nFactory åœ°å€: ${CONFIG.factory}\n`;
                output += `WDEV åœ°å€: ${CONFIG.wdev}\n`;
                output += `ETH åœ°å€: ${CONFIG.eth}\n`;
                output += `Multicall åœ°å€: ${CONFIG.multicall}\n`;
                output += `Init Code Hash: ${CONFIG.initCodeHash}\n`;
                
                result.textContent = output;
            } catch (error) {
                result.textContent = `âŒ é”™è¯¯: ${error.message}`;
            }
        }

        // è®¡ç®—äº¤æ˜“å¯¹åœ°å€ (ä½¿ç”¨ CREATE2)
        async function calculatePairAddress(tokenA, tokenB) {
            // æ’åº tokens
            const tokens = tokenA.toLowerCase() < tokenB.toLowerCase() ? [tokenA, tokenB] : [tokenB, tokenA];
            
            // ä½¿ç”¨ ethers.js è®¡ç®— CREATE2 åœ°å€
            if (typeof ethers === 'undefined') {
                // å¦‚æœæ²¡æœ‰ ethersï¼Œä½¿ç”¨æ‰‹åŠ¨è®¡ç®—
                const salt = keccak256(abi.encode(['address', 'address'], tokens));
                // è¿™é‡Œéœ€è¦å®Œæ•´çš„ CREATE2 è®¡ç®—ï¼Œç®€åŒ–ç‰ˆæœ¬
                return 'éœ€è¦ ethers.js åº“';
            }
            
            const salt = ethers.utils.solidityKeccak256(
                ['address', 'address'],
                [tokens[0], tokens[1]]
            );
            
            const bytecodeHash = CONFIG.initCodeHash;
            const pairAddress = ethers.utils.getCreate2Address(
                CONFIG.factory,
                salt,
                bytecodeHash
            );
            
            return pairAddress;
        }

        // æ£€æŸ¥äº¤æ˜“å¯¹åœ°å€
        async function checkPairAddress() {
            const result = document.getElementById('pairAddressResult');
            result.textContent = 'è®¡ç®—ä¸­...\n';
            
            try {
                // æ‰‹åŠ¨è®¡ç®— CREATE2 åœ°å€
                const token0 = CONFIG.wdev.toLowerCase() < CONFIG.eth.toLowerCase() ? CONFIG.wdev : CONFIG.eth;
                const token1 = CONFIG.wdev.toLowerCase() < CONFIG.eth.toLowerCase() ? CONFIG.eth : CONFIG.wdev;
                
                let output = '=== äº¤æ˜“å¯¹åœ°å€è®¡ç®— ===\n\n';
                output += `Token0 (è¾ƒå°åœ°å€): ${token0}\n`;
                output += `Token1 (è¾ƒå¤§åœ°å€): ${token1}\n`;
                output += `Factory: ${CONFIG.factory}\n`;
                output += `Init Code Hash: ${CONFIG.initCodeHash}\n\n`;
                output += 'âš ï¸ éœ€è¦ ethers.js åº“æ¥ç²¾ç¡®è®¡ç®— CREATE2 åœ°å€\n';
                output += 'è¯·ä½¿ç”¨æµè§ˆå™¨æ§åˆ¶å°è¿è¡Œå®Œæ•´è¯Šæ–­\n';
                
                result.textContent = output;
            } catch (error) {
                result.textContent = `âŒ é”™è¯¯: ${error.message}`;
            }
        }

        // æ£€æŸ¥äº¤æ˜“å¯¹æ˜¯å¦å­˜åœ¨
        async function checkPairExists() {
            const result = document.getElementById('pairExistsResult');
            result.textContent = 'æ£€æŸ¥ä¸­...\n';
            
            try {
                const ethereum = await getProvider();
                
                // Factory ABI
                const factoryABI = [
                    'function getPair(address tokenA, address tokenB) external view returns (address pair)'
                ];
                
                // è°ƒç”¨ getPair
                const data = ethers.utils.interface.encodeFunctionData(
                    'getPair',
                    [CONFIG.wdev, CONFIG.eth]
                );
                
                const pairAddress = await ethereum.request({
                    method: 'eth_call',
                    params: [{
                        to: CONFIG.factory,
                        data: data
                    }, 'latest']
                });
                
                const decoded = ethers.utils.defaultAbiCoder.decode(['address'], pairAddress);
                const pair = decoded[0];
                
                let output = '=== äº¤æ˜“å¯¹å­˜åœ¨æ€§æ£€æŸ¥ ===\n\n';
                output += `WDEV: ${CONFIG.wdev}\n`;
                output += `ETH: ${CONFIG.eth}\n\n`;
                output += `äº¤æ˜“å¯¹åœ°å€: ${pair}\n`;
                
                if (pair === '0x0000000000000000000000000000000000000000') {
                    output += 'âŒ äº¤æ˜“å¯¹ä¸å­˜åœ¨ï¼\n';
                    output += 'è¯·å…ˆåœ¨ Pool é¡µé¢åˆ›å»ºæµåŠ¨æ€§æ± \n';
                } else {
                    output += 'âœ… äº¤æ˜“å¯¹å­˜åœ¨\n';
                }
                
                result.textContent = output;
                window.pairAddress = pair;
            } catch (error) {
                result.textContent = `âŒ é”™è¯¯: ${error.message}\n\nè¯·ç¡®ä¿å·²å®‰è£… ethers.js åº“`;
            }
        }

        // æ£€æŸ¥ Reserves
        async function checkReserves() {
            const result = document.getElementById('reservesResult');
            result.textContent = 'æ£€æŸ¥ä¸­...\n';
            
            try {
                if (!window.pairAddress) {
                    result.textContent = 'âš ï¸ è¯·å…ˆè¿è¡Œ"æ£€æŸ¥äº¤æ˜“å¯¹æ˜¯å¦å­˜åœ¨"\n';
                    return;
                }
                
                if (window.pairAddress === '0x0000000000000000000000000000000000000000') {
                    result.textContent = 'âŒ äº¤æ˜“å¯¹ä¸å­˜åœ¨ï¼Œæ— æ³•è·å– Reserves\n';
                    return;
                }
                
                const ethereum = await getProvider();
                
                // Pair ABI
                const pairABI = [
                    'function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)',
                    'function token0() external view returns (address)',
                    'function token1() external view returns (address)'
                ];
                
                // è·å– reserves
                const reservesData = ethers.utils.interface.encodeFunctionData('getReserves', []);
                const reservesResult = await ethereum.request({
                    method: 'eth_call',
                    params: [{
                        to: window.pairAddress,
                        data: reservesData
                    }, 'latest']
                });
                
                const decoded = ethers.utils.defaultAbiCoder.decode(
                    ['uint112', 'uint112', 'uint32'],
                    reservesResult
                );
                
                let output = '=== Reserves æ£€æŸ¥ ===\n\n';
                output += `äº¤æ˜“å¯¹åœ°å€: ${window.pairAddress}\n\n`;
                output += `Reserve0: ${ethers.utils.formatEther(decoded[0])}\n`;
                output += `Reserve1: ${ethers.utils.formatEther(decoded[1])}\n`;
                output += `æœ€åæ›´æ–°æ—¶é—´: ${decoded[2]}\n\n`;
                
                if (decoded[0] === '0' && decoded[1] === '0') {
                    output += 'âŒ Reserves ä¸º 0ï¼ŒæµåŠ¨æ€§æ± ä¸ºç©º\n';
                } else {
                    output += 'âœ… Reserves æ­£å¸¸\n';
                }
                
                result.textContent = output;
            } catch (error) {
                result.textContent = `âŒ é”™è¯¯: ${error.message}\n\nè¯·ç¡®ä¿å·²å®‰è£… ethers.js åº“`;
            }
        }

        // æ£€æŸ¥ Multicall
        async function checkMulticall() {
            const result = document.getElementById('multicallResult');
            result.textContent = 'æ£€æŸ¥ä¸­...\n';
            
            try {
                if (!window.pairAddress || window.pairAddress === '0x0000000000000000000000000000000000000000') {
                    result.textContent = 'âš ï¸ è¯·å…ˆç¡®ä¿äº¤æ˜“å¯¹å­˜åœ¨\n';
                    return;
                }
                
                const ethereum = await getProvider();
                
                // Multicall ABI
                const multicallABI = [
                    'function aggregate(tuple(address target, bytes callData)[] calls) external returns (uint256 blockNumber, bytes[] returnData)'
                ];
                
                // å‡†å¤‡è°ƒç”¨æ•°æ®
                const pairABI = ['function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)'];
                const callData = ethers.utils.interface.encodeFunctionData('getReserves', []);
                
                const calls = [[window.pairAddress, callData]];
                const aggregateData = ethers.utils.interface.encodeFunctionData('aggregate', [calls]);
                
                const multicallResult = await ethereum.request({
                    method: 'eth_call',
                    params: [{
                        to: CONFIG.multicall,
                        data: aggregateData
                    }, 'latest']
                });
                
                let output = '=== Multicall æ£€æŸ¥ ===\n\n';
                output += `Multicall åœ°å€: ${CONFIG.multicall}\n`;
                output += `è°ƒç”¨æˆåŠŸ: âœ…\n`;
                output += `è¿”å›æ•°æ®é•¿åº¦: ${multicallResult.length} å­—ç¬¦\n`;
                
                result.textContent = output;
            } catch (error) {
                result.textContent = `âŒ é”™è¯¯: ${error.message}\n\nè¯·ç¡®ä¿å·²å®‰è£… ethers.js åº“`;
            }
        }

        // å®Œæ•´è¯Šæ–­
        async function fullDiagnosis() {
            const result = document.getElementById('fullDiagnosisResult');
            result.textContent = 'è¿è¡Œå®Œæ•´è¯Šæ–­...\n\n';
            
            try {
                await checkConfig();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                await checkPairExists();
                await new Promise(resolve => setTimeout(resolve, 500));
                
                if (window.pairAddress && window.pairAddress !== '0x0000000000000000000000000000000000000000') {
                    await checkReserves();
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    await checkMulticall();
                }
                
                result.textContent += '\n=== è¯Šæ–­å®Œæˆ ===\n';
                result.textContent += 'è¯·æŸ¥çœ‹ä¸Šé¢çš„å„é¡¹æ£€æŸ¥ç»“æœ\n';
            } catch (error) {
                result.textContent += `âŒ è¯Šæ–­è¿‡ç¨‹ä¸­å‡ºé”™: ${error.message}\n`;
            }
        }

        // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥
        window.onload = function() {
            if (typeof window.ethereum === 'undefined') {
                document.body.innerHTML += '<div class="container"><div class="error">âš ï¸ è¯·å…ˆå®‰è£…å¹¶è¿æ¥ MetaMask é’±åŒ…</div></div>';
            }
        };
        // æ£€æŸ¥ ethers æ˜¯å¦å·²åŠ è½½
        function checkEthers() {
            if (typeof ethers === 'undefined') {
                const script = document.createElement('script');
                script.src = 'https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js';
                script.onload = function() {
                    console.log('âœ… ethers.js å·²åŠ è½½');
                    // é‡æ–°åˆå§‹åŒ–
                    if (window.ethersReady) {
                        window.ethersReady();
                    }
                };
                document.head.appendChild(script);
                return false;
            }
            return true;
        }

        // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥
        window.onload = function() {
            if (typeof window.ethereum === 'undefined') {
                document.body.innerHTML += '<div class="container"><div class="error">âš ï¸ è¯·å…ˆå®‰è£…å¹¶è¿æ¥ MetaMask é’±åŒ…</div></div>';
            } else {
                checkEthers();
            }
        };

        // ç­‰å¾… ethers åŠ è½½å®Œæˆ
        window.ethersReady = function() {
            console.log('ethers.js å·²å‡†å¤‡å°±ç»ª');
        };
    </script>
    
    <!-- åŠ è½½ ethers.js -->
    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
    <script>
        // ç¡®ä¿ ethers åŠ è½½åå†æ‰§è¡Œ
        if (typeof ethers !== 'undefined') {
            window.ethersReady();
        }
    </script>
</body>
</html>
